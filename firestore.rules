/**
 * Core Philosophy:
 * This ruleset implements a Role-Based Access Control (RBAC) model. A dedicated
 * '/roles_admin' collection grants privileged users (Admins) comprehensive
 * management capabilities over products, inquiries, and user requests. Regular
 * authenticated users have restricted, ownership-based permissions, primarily
 * allowing them to create and view their own data (inquiries and requests)
 * but not modify it after submission.
 *
 * Data Structure:
 * The data is organized into flat, top-level collections for 'products',
 * 'inquiries', and 'requests'. This avoids complex hierarchical lookups. A
 * separate '/roles_admin/{userId}' collection serves as a lookup table to
 * determine admin status based on the existence of a document.
 *
 * Key Security Decisions:
 * - Admin Privilege: A user is considered an admin if a document with their
 *   UID exists in the '/roles_admin' collection. This check is performant and
 *   centralizes role management.
 * - Product Management: The '/products' collection is exclusively managed by
 *   admins. Following the specification, regular users do not have read or
 *   write access.
 * - User Submissions: Users can create their own inquiries and requests, but
 *   these documents become immutable for the user once created. Only admins can
 *   modify or delete them, treating them as system-of-record submissions.
 * - Deny by Default: Unspecified permissions are implicitly denied. Listing
 *   collections with user-specific data ('inquiries', 'requests') is denied for
 *   non-admins to prevent data leaks, forcing client-side queries to be specific
 *   (e.g., fetching only the user's own documents).
 *
 * Denormalization for Authorization:
 * The 'inquiries' and 'requests' collections denormalize the 'userId' field
 * directly onto each document. This is a critical design choice that allows
 * security rules to perform fast, simple, and cost-effective ownership checks
 * (isOwner(resource.data.userId)) without needing costly 'get()' calls to
 * other documents or collections.
 *
 * Structural Segregation:
 * This ruleset uses separate top-level collections for different data types
 * ('products', 'inquiries'). The '/roles_admin' collection is also structurally
 * segregated, ensuring that rules governing application data do not unintentionally
 * grant access to role-management data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an admin role.
     * Admin status is granted by the existence of a document in the roles_admin collection.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * Checks if the document existed before the current request.
     * Essential for safe update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Validates that the user making the request is the owner specified in the document.
     * Compares the document's owner field with the request's auth UID.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Validates ownership of a document that is being created.
     * Ensures the 'userId' field in the new data matches the creator's UID.
     */
    function isCreatingOwnDoc(userIdField) {
      return request.resource.data[userIdField] == request.auth.uid;
    }
    
    /**
     * Combines an ownership check with an existence check for existing documents.
     * Used for update and delete operations to ensure the user is modifying their own, existing data.
     */
    // function isExistingOwner(userId) {
    //     return isOwner(userId) && isExistingDoc();
    // }


    /**
     * @description Manages product listings. Only admins can perform any action.
     * @path /products/{productId}
     * @allow An admin (create) a new product document.
     * @deny A non-admin user (get) a product document.
     * @principle Enforces strict role-based access for a managed collection.
     */
    match /products/{productId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Manages user inquiries about products. Users create their own, admins manage all.
     * @path /inquiries/{inquiryId}
     * @allow A signed-in user (create) an inquiry with their own userId.
     * @deny A user (update) their own inquiry after it has been created.
     * @principle Implements a submission model: users can create, but only admins can manage records.
     */
    match /inquiries/{inquiryId} {
      allow get: if isOwner(resource.data.userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isSignedIn() && isCreatingOwnDoc('userId');
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Manages user requests to sell a device. Users create their own, admins manage all.
     * @path /requests/{requestId}
     * @allow A signed-in user (create) a request with their own userId.
     * @deny A user (delete) another user's request.
     * @principle Implements a submission model: users can create, but only admins can manage records.
     */
    match /requests/{requestId} {
      allow get: if isOwner(resource.data.userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isSignedIn() && isCreatingOwnDoc('userId');
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Defines admin roles. The existence of a doc grants admin rights. This collection is read-only.
     * @path /roles_admin/{userId}
     * @allow An admin role check via exists() is permitted by other rules.
     * @deny Any client (create) a new role document to escalate privileges.
     * @principle Prevents privilege escalation by making role assignments a server-side or console-only operation.
     */
    match /roles_admin/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}